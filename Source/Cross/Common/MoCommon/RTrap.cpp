#include "MoCmSystem.h"
#include "MoCmThread.h"

MO_NAMESPACE_BEGIN

//============================================================
// <T>陷阱管理对象实例声明。</T>
//============================================================
RTrap RTrap::_instance;

//============================================================
// <T>获得静态对象。</T>
//============================================================
RTrap& RTrap::Static(){
   return _instance;
}

//============================================================
// <T>创建陷阱管理对象。</T>
//============================================================
RTrap::RTrap(){
}

//============================================================
// <T>释放陷阱管理对象。</T>
//============================================================
RTrap::~RTrap(){
}

//============================================================
// <T>获得当前线程陷阱对象。</T>
//
// @return 线程陷阱对象
//============================================================
FThreadTrap* RTrap::CurrentThreadTrap(){
   return RThreadManager::Instance().Current()->ThreadTrap();
}

//============================================================
// <T>获得当前线程激活的陷阱对象。</T>
//
// @return 陷阱对象
//============================================================
FTrap* RTrap::CurrentTrap(){
   return CurrentThreadTrap()->CurrentTrap();
}

//============================================================
// <T>关联线程陷阱。</T>
//============================================================
FThreadTrap* RTrap::Link(){
   // 获得线程陷阱
   FThreadTrap* pThreadTrap = CurrentThreadTrap();
   MO_ASSERT(pThreadTrap);
   // 增加一层
   pThreadTrap->Push();
   return pThreadTrap;
}

//============================================================
// <T>取消关联线程陷阱。</T>
//
// @param pThreadTrap 线程陷阱对象
//============================================================
void RTrap::Unlink(FThreadTrap* pThreadTrap){
   // 回退一层陷阱
   pThreadTrap->Pop();
}

MO_NAMESPACE_END
